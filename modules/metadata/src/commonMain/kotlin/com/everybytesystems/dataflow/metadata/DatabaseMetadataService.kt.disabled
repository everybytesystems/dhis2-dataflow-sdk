package com.everybytesystems.dataflow.metadata

import com.everybytesystems.dataflow.core.cache.CacheManager
import com.everybytesystems.dataflow.core.config.DHIS2Config
import com.everybytesystems.dataflow.core.network.ApiResponse
import com.everybytesystems.dataflow.core.sync.SyncManager
import com.everybytesystems.dataflow.metadata.database.MetadataDatabase
import com.everybytesystems.dataflow.metadata.models.*
import io.ktor.client.*
import io.ktor.client.call.*
import io.ktor.client.request.*
import io.ktor.http.*
import kotlinx.coroutines.flow.*
import kotlinx.datetime.Clock
import kotlin.time.Duration.Companion.hours

/**
 * Service for managing DHIS2 metadata synchronization and caching
 * TODO: Re-enable when SQLDelight is configured
 */
class DatabaseMetadataService(
    private val config: DHIS2Config,
    private val httpClient: HttpClient,
    private val database: MetadataDatabase,
    private val cacheManager: CacheManager,
    private val syncManager: SyncManager
) {
    
    /**
     * Synchronize all metadata from server
     */
    suspend fun syncAll(forceRefresh: Boolean = false): ApiResponse<Unit> {
        return try {
            if (!forceRefresh && cacheManager.exists(METADATA_CACHE_KEY)) {
                ApiResponse.success(Unit)
            } else {
                val response = fetchMetadataFromServer()
                when (response) {
                    is ApiResponse.Success -> {
                        storeMetadata(response.data)
                        cacheManager.put(METADATA_CACHE_KEY, response.data, ttl = 24.hours)
                        syncManager.updateSyncStatus("metadata", status = "success")
                        ApiResponse.success(Unit)
                    }
                    is ApiResponse.Error -> {
                        syncManager.updateSyncStatus("metadata", status = "error", errorMessage = response.message)
                        response
                    }
                    is ApiResponse.Loading -> response
                }
            }
        } catch (e: Exception) {
            syncManager.updateSyncStatus("metadata", status = "error", errorMessage = e.message)
            ApiResponse.error(e, "Failed to sync metadata")
        }
    }
    
    /**
     * Get all data elements
     */
    suspend fun getDataElements(): List<DataElement> {
        return try {
            // TODO: Implement with database when SQLDelight is enabled
            // val cached = database.metadataQueries.selectAllDataElements().executeAsList()
            // cached.map { it.toDataElement() }
            emptyList()
        } catch (e: Exception) {
            emptyList()
        }
    }
    
    /**
     * Get data element by ID
     */
    suspend fun getDataElement(id: String): DataElement? {
        return try {
            // TODO: Implement with database when SQLDelight is enabled
            // database.metadataQueries.selectDataElementById(id).executeAsOneOrNull()?.toDataElement()
            null
        } catch (e: Exception) {
            null
        }
    }
    
    /**
     * Get data elements by IDs
     */
    suspend fun getDataElements(ids: List<String>): List<DataElement> {
        return try {
            // TODO: Implement with database when SQLDelight is enabled
            // database.metadataQueries.selectDataElementsByIds(ids).executeAsList()
            //     .map { it.toDataElement() }
            emptyList()
        } catch (e: Exception) {
            emptyList()
        }
    }
    
    /**
     * Get all data sets
     */
    suspend fun getDataSets(): List<DataSet> {
        return try {
            database.metadataQueries.selectAllDataSets().executeAsList()
                .map { it.toDataSet() }
        } catch (e: Exception) {
            emptyList()
        }
    }
    
    /**
     * Get data set by ID
     */
    suspend fun getDataSet(id: String): DataSet? {
        return try {
            database.metadataQueries.selectDataSetById(id).executeAsOneOrNull()?.toDataSet()
        } catch (e: Exception) {
            null
        }
    }
    
    /**
     * Get data elements for a specific data set
     */
    suspend fun getDataElementsForDataSet(dataSetId: String): List<DataElement> {
        return try {
            database.metadataQueries.selectDataElementsByDataSet(dataSetId).executeAsList()
                .map { it.toDataElement() }
        } catch (e: Exception) {
            emptyList()
        }
    }
    
    /**
     * Get all organisation units
     */
    suspend fun getOrganisationUnits(): List<OrganisationUnit> {
        return try {
            database.metadataQueries.selectAllOrganisationUnits().executeAsList()
                .map { it.toOrganisationUnit() }
        } catch (e: Exception) {
            emptyList()
        }
    }
    
    /**
     * Get organisation unit by ID
     */
    suspend fun getOrganisationUnit(id: String): OrganisationUnit? {
        return try {
            database.metadataQueries.selectOrganisationUnitById(id).executeAsOneOrNull()?.toOrganisationUnit()
        } catch (e: Exception) {
            null
        }
    }
    
    /**
     * Get organisation units by level
     */
    suspend fun getOrganisationUnitsByLevel(level: Int): List<OrganisationUnit> {
        return try {
            database.metadataQueries.selectOrganisationUnitsByLevel(level.toLong()).executeAsList()
                .map { it.toOrganisationUnit() }
        } catch (e: Exception) {
            emptyList()
        }
    }
    
    /**
     * Get child organisation units
     */
    suspend fun getChildOrganisationUnits(parentId: String): List<OrganisationUnit> {
        return try {
            database.metadataQueries.selectOrganisationUnitsByParent(parentId).executeAsList()
                .map { it.toOrganisationUnit() }
        } catch (e: Exception) {
            emptyList()
        }
    }
    
    /**
     * Get all programs
     */
    suspend fun getPrograms(): List<Program> {
        return try {
            database.metadataQueries.selectAllPrograms().executeAsList()
                .map { it.toProgram() }
        } catch (e: Exception) {
            emptyList()
        }
    }
    
    /**
     * Get program by ID
     */
    suspend fun getProgram(id: String): Program? {
        return try {
            database.metadataQueries.selectProgramById(id).executeAsOneOrNull()?.toProgram()
        } catch (e: Exception) {
            null
        }
    }
    
    /**
     * Get program stages for a program
     */
    suspend fun getProgramStages(programId: String): List<ProgramStage> {
        return try {
            database.metadataQueries.selectProgramStagesByProgram(programId).executeAsList()
                .map { it.toProgramStage() }
        } catch (e: Exception) {
            emptyList()
        }
    }
    
    /**
     * Get all option sets
     */
    suspend fun getOptionSets(): List<OptionSet> {
        return try {
            database.metadataQueries.selectAllOptionSets().executeAsList()
                .map { it.toOptionSet() }
        } catch (e: Exception) {
            emptyList()
        }
    }
    
    /**
     * Get option set by ID
     */
    suspend fun getOptionSet(id: String): OptionSet? {
        return try {
            database.metadataQueries.selectOptionSetById(id).executeAsOneOrNull()?.toOptionSet()
        } catch (e: Exception) {
            null
        }
    }
    
    /**
     * Get options for an option set
     */
    suspend fun getOptions(optionSetId: String): List<Option> {
        return try {
            database.metadataQueries.selectOptionsByOptionSet(optionSetId).executeAsList()
                .map { it.toOption() }
        } catch (e: Exception) {
            emptyList()
        }
    }
    
    /**
     * Search data elements by name
     */
    suspend fun searchDataElements(query: String): List<DataElement> {
        return getDataElements().filter { 
            it.name.contains(query, ignoreCase = true) || 
            it.displayName?.contains(query, ignoreCase = true) == true ||
            it.code?.contains(query, ignoreCase = true) == true
        }
    }
    
    /**
     * Search organisation units by name
     */
    suspend fun searchOrganisationUnits(query: String): List<OrganisationUnit> {
        return getOrganisationUnits().filter { 
            it.name.contains(query, ignoreCase = true) || 
            it.displayName?.contains(query, ignoreCase = true) == true ||
            it.code?.contains(query, ignoreCase = true) == true
        }
    }
    
    private suspend fun fetchMetadataFromServer(): ApiResponse<MetadataResponse> {
        return try {
            val response = httpClient.get(config.metadataUrl) {
                parameter("fields", METADATA_FIELDS)
                parameter("paging", "false")
            }
            
            if (response.status.isSuccess()) {
                val metadata = response.body<MetadataResponse>()
                ApiResponse.success(metadata)
            } else {
                ApiResponse.error(Exception("HTTP ${response.status.value}: ${response.status.description}"))
            }
        } catch (e: Exception) {
            ApiResponse.error(e, "Failed to fetch metadata from server")
        }
    }
    
    private suspend fun storeMetadata(metadata: MetadataResponse) {
        val syncVersion = Clock.System.now().toEpochMilliseconds().toString()
        
        // Store data elements
        metadata.dataElements.forEach { dataElement ->
            database.metadataQueries.insertDataElement(
                id = dataElement.id,
                name = dataElement.name,
                display_name = dataElement.displayName,
                short_name = dataElement.shortName,
                code = dataElement.code,
                description = dataElement.description,
                value_type = dataElement.valueType.name,
                aggregation_type = dataElement.aggregationType.name,
                domain_type = dataElement.domainType.name,
                category_combo_id = dataElement.categoryCombo?.id,
                option_set_id = dataElement.optionSet?.id,
                created = dataElement.created,
                last_updated = dataElement.lastUpdated,
                sync_version = syncVersion
            )
        }
        
        // Store data sets
        metadata.dataSets.forEach { dataSet ->
            database.metadataQueries.insertDataSet(
                id = dataSet.id,
                name = dataSet.name,
                display_name = dataSet.displayName,
                short_name = dataSet.shortName,
                code = dataSet.code,
                description = dataSet.description,
                period_type = dataSet.periodType.name,
                category_combo_id = dataSet.categoryCombo?.id,
                created = dataSet.created,
                last_updated = dataSet.lastUpdated,
                sync_version = syncVersion
            )
            
            // Store data set elements relationships
            dataSet.dataSetElements.forEach { dataSetElement ->
                database.metadataQueries.insertDataSetElement(
                    data_set_id = dataSet.id,
                    data_element_id = dataSetElement.dataElement.id,
                    category_combo_id = dataSetElement.categoryCombo?.id
                )
            }
        }
        
        // Store organisation units
        metadata.organisationUnits.forEach { orgUnit ->
            database.metadataQueries.insertOrganisationUnit(
                id = orgUnit.id,
                name = orgUnit.name,
                display_name = orgUnit.displayName,
                short_name = orgUnit.shortName,
                code = orgUnit.code,
                description = orgUnit.description,
                level = orgUnit.level?.toLong(),
                path = orgUnit.path,
                parent_id = orgUnit.parent?.id,
                geometry = orgUnit.geometry?.let { "${it.type}:${it.coordinates.joinToString(",")}" },
                created = orgUnit.created,
                last_updated = orgUnit.lastUpdated,
                sync_version = syncVersion
            )
        }
        
        // Store programs
        metadata.programs.forEach { program ->
            database.metadataQueries.insertProgram(
                id = program.id,
                name = program.name,
                display_name = program.displayName,
                short_name = program.shortName,
                code = program.code,
                description = program.description,
                program_type = program.programType.name,
                category_combo_id = program.categoryCombo?.id,
                created = program.created,
                last_updated = program.lastUpdated,
                sync_version = syncVersion
            )
        }
        
        // Store program stages
        metadata.programs.forEach { program ->
            program.programStages.forEach { stage ->
                database.metadataQueries.insertProgramStage(
                    id = stage.id,
                    name = stage.name,
                    display_name = stage.displayName,
                    code = stage.code,
                    description = stage.description,
                    program_id = program.id,
                    sort_order = stage.sortOrder?.toLong(),
                    repeatable = if (stage.repeatable) 1 else 0,
                    created = stage.created,
                    last_updated = stage.lastUpdated,
                    sync_version = syncVersion
                )
            }
        }
        
        // Store option sets and options
        metadata.optionSets.forEach { optionSet ->
            database.metadataQueries.insertOptionSet(
                id = optionSet.id,
                name = optionSet.name,
                display_name = optionSet.displayName,
                code = optionSet.code,
                value_type = optionSet.valueType.name,
                created = optionSet.created,
                last_updated = optionSet.lastUpdated,
                sync_version = syncVersion
            )
            
            optionSet.options.forEach { option ->
                database.metadataQueries.insertOption(
                    id = option.id,
                    name = option.name,
                    display_name = option.displayName,
                    code = option.code,
                    option_set_id = optionSet.id,
                    sort_order = option.sortOrder?.toLong(),
                    created = option.created,
                    last_updated = option.lastUpdated,
                    sync_version = syncVersion
                )
            }
        }
    }
    
    companion object {
        private const val METADATA_CACHE_KEY = "dhis2_metadata"
        private const val METADATA_FIELDS = "id,name,displayName,shortName,code,description,created,lastUpdated," +
                "valueType,aggregationType,domainType,periodType,programType,level,path,parent[id]," +
                "categoryCombo[id],optionSet[id],options[id,name,displayName,code,sortOrder]," +
                "dataSetElements[dataElement[id],categoryCombo[id]]," +
                "programStages[id,name,displayName,code,description,sortOrder,repeatable]," +
                "geometry[type,coordinates]"
    }
}

// Extension functions to convert database entities to domain models
private fun com.everybytesystems.dataflow.metadata.database.Data_elements.toDataElement(): DataElement {
    return DataElement(
        id = id,
        name = name,
        displayName = display_name,
        shortName = short_name,
        code = code,
        description = description,
        valueType = ValueType.valueOf(value_type),
        aggregationType = AggregationType.valueOf(aggregation_type),
        domainType = DomainType.valueOf(domain_type),
        created = created,
        lastUpdated = last_updated
    )
}

private fun com.everybytesystems.dataflow.metadata.database.Data_sets.toDataSet(): DataSet {
    return DataSet(
        id = id,
        name = name,
        displayName = display_name,
        shortName = short_name,
        code = code,
        description = description,
        periodType = PeriodType.valueOf(period_type),
        created = created,
        lastUpdated = last_updated
    )
}

private fun com.everybytesystems.dataflow.metadata.database.Organisation_units.toOrganisationUnit(): OrganisationUnit {
    return OrganisationUnit(
        id = id,
        name = name,
        displayName = display_name,
        shortName = short_name,
        code = code,
        description = description,
        level = level?.toInt(),
        path = path,
        created = created,
        lastUpdated = last_updated
    )
}

private fun com.everybytesystems.dataflow.metadata.database.Programs.toProgram(): Program {
    return Program(
        id = id,
        name = name,
        displayName = display_name,
        shortName = short_name,
        code = code,
        description = description,
        programType = ProgramType.valueOf(program_type),
        created = created,
        lastUpdated = last_updated
    )
}

private fun com.everybytesystems.dataflow.metadata.database.Program_stages.toProgramStage(): ProgramStage {
    return ProgramStage(
        id = id,
        name = name,
        displayName = display_name,
        code = code,
        description = description,
        sortOrder = sort_order?.toInt(),
        repeatable = repeatable == 1L,
        created = created,
        lastUpdated = last_updated
    )
}

// TODO: Re-enable when SQLDelight is configured
/*
private fun com.everybytesystems.dataflow.metadata.database.Option_sets.toOptionSet(): OptionSet {
    return OptionSet(
        id = id,
        name = name,
        displayName = display_name,
        code = code,
        valueType = ValueType.valueOf(value_type),
        created = created,
        lastUpdated = last_updated
    )
}

private fun com.everybytesystems.dataflow.metadata.database.Options.toOption(): Option {
    return Option(
        id = id,
        name = name,
        displayName = display_name,
        code = code,
        sortOrder = sort_order?.toInt(),
        created = created,
        lastUpdated = last_updated
    )
}
*/